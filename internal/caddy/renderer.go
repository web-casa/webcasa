package caddy

import (
	"encoding/json"
	"fmt"
	"sort"
	"strings"
	"time"

	"github.com/web-casa/webcasa/internal/config"
	"github.com/web-casa/webcasa/internal/model"
)

// RenderCaddyfile generates a complete Caddyfile from the given hosts
func RenderCaddyfile(hosts []model.Host, cfg *config.Config, dnsProviders map[uint]model.DnsProvider) string {
	var b strings.Builder

	// Header
	b.WriteString("# ============================================\n")
	b.WriteString("# Auto-generated by WebCasa\n")
	b.WriteString("# DO NOT EDIT MANUALLY — changes will be overwritten\n")
	b.WriteString(fmt.Sprintf("# Generated at: %s\n", time.Now().Format(time.RFC3339)))
	b.WriteString("# ============================================\n\n")

	// Global options block
	b.WriteString("{\n")
	b.WriteString("\tadmin localhost:2019\n")
	b.WriteString(fmt.Sprintf("\tlog {\n\t\toutput file %s/caddy.log {\n\t\t\troll_size 100MiB\n\t\t\troll_keep 5\n\t\t}\n\t\tlevel INFO\n\t}\n", cfg.LogDir))
	b.WriteString("}\n\n")

	// Host blocks — only enabled hosts
	for _, host := range hosts {
		if host.Enabled != nil && !*host.Enabled {
			continue
		}
		renderHostBlock(&b, host, cfg, dnsProviders)
	}

	return b.String()
}

func renderHostBlock(b *strings.Builder, host model.Host, cfg *config.Config, dnsProviders map[uint]model.DnsProvider) {
	// Domain line
	domain := host.Domain
	tlsMode := host.TLSMode
	if tlsMode == "" {
		tlsMode = "auto"
	}

	// Handle TLS mode for domain prefix
	if tlsMode == "off" || (host.TLSEnabled != nil && !*host.TLSEnabled) {
		domain = "http://" + domain
	}

	b.WriteString(fmt.Sprintf("%s {\n", domain))

	// TLS configuration based on mode
	switch tlsMode {
	case "custom":
		if host.CustomCertPath != "" && host.CustomKeyPath != "" {
			b.WriteString(fmt.Sprintf("\ttls %s %s\n", host.CustomCertPath, host.CustomKeyPath))
		}
	case "dns", "wildcard":
		if host.DnsProviderID != nil {
			if p, ok := dnsProviders[*host.DnsProviderID]; ok {
				renderDnsTLS(b, p)
			}
		}
	case "off":
		// no TLS block needed, http:// prefix handles it
		// case "auto": default Caddy behavior, no tls block needed
	}

	// Response compression
	if host.Compression != nil && *host.Compression {
		renderCompression(b)
	}

	// Access rules (IP allow/deny) — must come before handlers
	if len(host.AccessRules) > 0 {
		renderAccessRules(b, host.AccessRules)
	}

	// Basic Auth — must come before handlers
	if len(host.BasicAuths) > 0 {
		renderBasicAuth(b, host.BasicAuths)
	}

	// CORS
	if host.CorsEnabled != nil && *host.CorsEnabled {
		renderCors(b, host)
	}

	// Security headers
	if host.SecurityHeaders != nil && *host.SecurityHeaders {
		renderSecurityHeaders(b)
	}

	// Render based on host type
	switch host.HostType {
	case "redirect":
		renderRedirect(b, host)
	case "static":
		renderStaticHost(b, host)
	case "php":
		renderPHPHost(b, host)
	default: // "proxy" or empty (backward compatible)
		renderProxyHost(b, host)
	}

	// Custom directives (raw user-provided Caddy config)
	if host.CustomDirectives != "" {
		for _, line := range strings.Split(strings.TrimSpace(host.CustomDirectives), "\n") {
			b.WriteString(fmt.Sprintf("\t%s\n", line))
		}
	}

	// Custom error pages
	if host.ErrorPagePath != "" {
		renderErrorPages(b, host.ErrorPagePath)
	}

	// Per-host access log
	b.WriteString(fmt.Sprintf("\tlog {\n\t\toutput file %s/access-%s.log {\n\t\t\troll_size 50MiB\n\t\t\troll_keep 3\n\t\t}\n\t}\n", cfg.LogDir, host.Domain))

	b.WriteString("}\n\n")
}

func renderRedirect(b *strings.Builder, host model.Host) {
	scheme := "permanent" // 301
	if host.RedirectCode == 302 {
		scheme = "temporary" // 302
	}
	b.WriteString(fmt.Sprintf("\tredir %s%s %s\n", host.RedirectURL, "{uri}", scheme))
}

func renderProxyHost(b *strings.Builder, host model.Host) {
	// Sort upstreams by sort_order
	upstreams := make([]model.Upstream, len(host.Upstreams))
	copy(upstreams, host.Upstreams)
	sort.Slice(upstreams, func(i, j int) bool {
		return upstreams[i].SortOrder < upstreams[j].SortOrder
	})

	// If we have path-based routes, render them separately
	if len(host.Routes) > 0 {
		renderRoutes(b, host)
	} else if len(upstreams) > 0 {
		// Simple reverse proxy (no path routing)
		renderReverseProxy(b, upstreams, host.WebSocket != nil && *host.WebSocket)
	}

	// Custom response headers
	renderResponseHeaders(b, host.CustomHeaders)
}

func renderBasicAuth(b *strings.Builder, auths []model.BasicAuth) {
	b.WriteString("\tbasicauth {\n")
	for _, auth := range auths {
		b.WriteString(fmt.Sprintf("\t\t%s %s\n", auth.Username, auth.PasswordHash))
	}
	b.WriteString("\t}\n")
}

func renderReverseProxy(b *strings.Builder, upstreams []model.Upstream, websocket bool) {
	addrs := make([]string, len(upstreams))
	isPublicURL := false
	for i, u := range upstreams {
		addrs[i] = u.Address
		if strings.HasPrefix(u.Address, "http://") || strings.HasPrefix(u.Address, "https://") {
			isPublicURL = true
		}
	}

	b.WriteString(fmt.Sprintf("\treverse_proxy %s {\n", strings.Join(addrs, " ")))

	if len(upstreams) > 1 {
		b.WriteString("\t\tlb_policy round_robin\n")
	}

	// For public URL upstreams (e.g. https://eol.wiki),
	// set Host header to the upstream's hostname so the target site
	// receives the correct Host header instead of the proxy's domain
	if isPublicURL {
		b.WriteString("\t\theader_up Host {upstream_hostport}\n")
	}

	// X-Real-IP is not set by Caddy by default, so we keep it
	b.WriteString("\t\theader_up X-Real-IP {remote_host}\n")

	b.WriteString("\t}\n")
}

func renderRoutes(b *strings.Builder, host model.Host) {
	routes := make([]model.Route, len(host.Routes))
	copy(routes, host.Routes)
	sort.Slice(routes, func(i, j int) bool {
		return routes[i].SortOrder < routes[j].SortOrder
	})

	// Build upstream map
	upstreamMap := make(map[uint]model.Upstream)
	for _, u := range host.Upstreams {
		upstreamMap[u.ID] = u
	}

	for _, route := range routes {
		matcherName := fmt.Sprintf("path_%d", route.ID)
		b.WriteString(fmt.Sprintf("\t@%s path %s\n", matcherName, route.Path))

		if route.UpstreamID != nil {
			if upstream, ok := upstreamMap[*route.UpstreamID]; ok {
				b.WriteString(fmt.Sprintf("\treverse_proxy @%s %s\n", matcherName, upstream.Address))
			}
		}
	}
}

func renderAccessRules(b *strings.Builder, rules []model.AccessRule) {
	sorted := make([]model.AccessRule, len(rules))
	copy(sorted, rules)
	sort.Slice(sorted, func(i, j int) bool {
		return sorted[i].SortOrder < sorted[j].SortOrder
	})

	for _, rule := range sorted {
		switch rule.RuleType {
		case "allow":
			b.WriteString(fmt.Sprintf("\t@blocked not remote_ip %s\n", rule.IPRange))
			b.WriteString("\tabort @blocked\n")
		case "deny":
			b.WriteString(fmt.Sprintf("\t@denied remote_ip %s\n", rule.IPRange))
			b.WriteString("\tabort @denied\n")
		}
	}
}

func renderResponseHeaders(b *strings.Builder, headers []model.CustomHeader) {
	if len(headers) == 0 {
		return
	}

	sorted := make([]model.CustomHeader, len(headers))
	copy(sorted, headers)
	sort.Slice(sorted, func(i, j int) bool {
		return sorted[i].SortOrder < sorted[j].SortOrder
	})

	b.WriteString("\theader {\n")
	for _, h := range sorted {
		switch h.Operation {
		case "set":
			b.WriteString(fmt.Sprintf("\t\t%s \"%s\"\n", h.Name, h.Value))
		case "add":
			b.WriteString(fmt.Sprintf("\t\t+%s \"%s\"\n", h.Name, h.Value))
		case "delete":
			b.WriteString(fmt.Sprintf("\t\t-%s\n", h.Name))
		}
	}
	b.WriteString("\t}\n")
}

func renderCompression(b *strings.Builder) {
	b.WriteString("\tencode gzip zstd\n")
}

func renderCors(b *strings.Builder, host model.Host) {
	origins := host.CorsOrigins
	if origins == "" {
		origins = "*"
	}
	methods := host.CorsMethods
	if methods == "" {
		methods = "GET, POST, PUT, DELETE, OPTIONS"
	}
	headers := host.CorsHeaders
	if headers == "" {
		headers = "Content-Type, Authorization"
	}

	// Preflight
	b.WriteString("\t@cors_preflight method OPTIONS\n")
	b.WriteString("\theader @cors_preflight {\n")
	b.WriteString(fmt.Sprintf("\t\tAccess-Control-Allow-Origin \"%s\"\n", origins))
	b.WriteString(fmt.Sprintf("\t\tAccess-Control-Allow-Methods \"%s\"\n", methods))
	b.WriteString(fmt.Sprintf("\t\tAccess-Control-Allow-Headers \"%s\"\n", headers))
	b.WriteString("\t\tAccess-Control-Max-Age \"86400\"\n")
	b.WriteString("\t}\n")
	b.WriteString("\trespond @cors_preflight 204\n")

	// Normal response
	b.WriteString(fmt.Sprintf("\theader Access-Control-Allow-Origin \"%s\"\n", origins))
}

func renderSecurityHeaders(b *strings.Builder) {
	b.WriteString("\theader {\n")
	b.WriteString("\t\tStrict-Transport-Security \"max-age=31536000; includeSubDomains; preload\"\n")
	b.WriteString("\t\tX-Content-Type-Options \"nosniff\"\n")
	b.WriteString("\t\tX-Frame-Options \"DENY\"\n")
	b.WriteString("\t\tReferrer-Policy \"strict-origin-when-cross-origin\"\n")
	b.WriteString("\t\tX-XSS-Protection \"1; mode=block\"\n")
	b.WriteString("\t\tPermissions-Policy \"camera=(), microphone=(), geolocation=()\"\n")
	b.WriteString("\t}\n")
}

func renderErrorPages(b *strings.Builder, errorPagePath string) {
	b.WriteString("\thandle_errors {\n")
	for _, code := range []int{404, 502, 503} {
		b.WriteString(fmt.Sprintf("\t\t@%d expression {err.status_code} == %d\n", code, code))
		b.WriteString(fmt.Sprintf("\t\thandle @%d {\n", code))
		b.WriteString(fmt.Sprintf("\t\t\troot * %s\n", errorPagePath))
		b.WriteString(fmt.Sprintf("\t\t\trewrite * /%d.html\n", code))
		b.WriteString("\t\t\tfile_server\n")
		b.WriteString("\t\t}\n")
	}
	b.WriteString("\t}\n")
}

func renderStaticHost(b *strings.Builder, host model.Host) {
	b.WriteString(fmt.Sprintf("\troot * %s\n", host.RootPath))
	if host.IndexFiles != "" {
		b.WriteString(fmt.Sprintf("\ttry_files {path} %s\n", host.IndexFiles))
	}
	if host.DirectoryBrowse != nil && *host.DirectoryBrowse {
		b.WriteString("\tfile_server browse\n")
	} else {
		b.WriteString("\tfile_server\n")
	}
}

func renderPHPHost(b *strings.Builder, host model.Host) {
	b.WriteString(fmt.Sprintf("\troot * %s\n", host.RootPath))
	fastcgi := host.PHPFastCGI
	if fastcgi == "" {
		fastcgi = "localhost:9000"
	}
	b.WriteString(fmt.Sprintf("\tphp_fastcgi %s\n", fastcgi))
	b.WriteString("\tfile_server\n")
}

func renderDnsTLS(b *strings.Builder, p model.DnsProvider) {
	// Parse JSON config to extract API token/key
	var cfg map[string]string
	if err := json.Unmarshal([]byte(p.Config), &cfg); err != nil {
		return // skip if config is invalid
	}

	// Map provider to Caddy module name and config key
	switch p.Provider {
	case "cloudflare":
		token := cfg["api_token"]
		if token == "" {
			return
		}
		b.WriteString("\ttls {\n")
		b.WriteString("\t\tdns cloudflare " + token + "\n")
		b.WriteString("\t}\n")
	case "alidns":
		ak := cfg["access_key_id"]
		sk := cfg["access_key_secret"]
		if ak == "" || sk == "" {
			return
		}
		b.WriteString("\ttls {\n")
		b.WriteString(fmt.Sprintf("\t\tdns alidns {\n\t\t\taccess_key_id %s\n\t\t\taccess_key_secret %s\n\t\t}\n", ak, sk))
		b.WriteString("\t}\n")
	case "tencentcloud":
		sid := cfg["secret_id"]
		sk := cfg["secret_key"]
		if sid == "" || sk == "" {
			return
		}
		b.WriteString("\ttls {\n")
		b.WriteString(fmt.Sprintf("\t\tdns tencentcloud {\n\t\t\tsecret_id %s\n\t\t\tsecret_key %s\n\t\t}\n", sid, sk))
		b.WriteString("\t}\n")
	case "route53":
		region := cfg["region"]
		ak := cfg["access_key_id"]
		sk := cfg["secret_access_key"]
		if ak == "" || sk == "" {
			return
		}
		if region == "" {
			region = "us-east-1"
		}
		b.WriteString("\ttls {\n")
		b.WriteString(fmt.Sprintf("\t\tdns route53 {\n\t\t\tregion %s\n\t\t\taccess_key_id %s\n\t\t\tsecret_access_key %s\n\t\t}\n", region, ak, sk))
		b.WriteString("\t}\n")
	}
}
