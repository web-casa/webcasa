package caddy

import (
	"fmt"
	"sort"
	"strings"
	"time"

	"github.com/caddypanel/caddypanel/internal/config"
	"github.com/caddypanel/caddypanel/internal/model"
)

// RenderCaddyfile generates a complete Caddyfile from the given hosts
func RenderCaddyfile(hosts []model.Host, cfg *config.Config) string {
	var b strings.Builder

	// Header
	b.WriteString("# ============================================\n")
	b.WriteString("# Auto-generated by CaddyPanel\n")
	b.WriteString("# DO NOT EDIT MANUALLY — changes will be overwritten\n")
	b.WriteString(fmt.Sprintf("# Generated at: %s\n", time.Now().Format(time.RFC3339)))
	b.WriteString("# ============================================\n\n")

	// Global options block
	b.WriteString("{\n")
	b.WriteString("\tadmin localhost:2019\n")
	b.WriteString(fmt.Sprintf("\tlog {\n\t\toutput file %s/caddy.log {\n\t\t\troll_size 100MiB\n\t\t\troll_keep 5\n\t\t}\n\t\tlevel INFO\n\t}\n", cfg.LogDir))
	b.WriteString("}\n\n")

	// Host blocks — only enabled hosts
	for _, host := range hosts {
		if !host.Enabled {
			continue
		}
		renderHostBlock(&b, host, cfg)
	}

	return b.String()
}

func renderHostBlock(b *strings.Builder, host model.Host, cfg *config.Config) {
	// Domain line
	domain := host.Domain
	if !host.TLSEnabled {
		domain = "http://" + domain
	}

	b.WriteString(fmt.Sprintf("%s {\n", domain))

	// Access rules (IP allow/deny) — must come before handlers
	if len(host.AccessRules) > 0 {
		renderAccessRules(b, host.AccessRules)
	}

	// Sort upstreams by sort_order
	upstreams := make([]model.Upstream, len(host.Upstreams))
	copy(upstreams, host.Upstreams)
	sort.Slice(upstreams, func(i, j int) bool {
		return upstreams[i].SortOrder < upstreams[j].SortOrder
	})

	// If we have path-based routes, render them separately
	if len(host.Routes) > 0 {
		renderRoutes(b, host)
	} else if len(upstreams) > 0 {
		// Simple reverse proxy (no path routing)
		renderReverseProxy(b, upstreams, host.WebSocket)
	}

	// Custom response headers
	renderResponseHeaders(b, host.CustomHeaders)

	// Per-host access log
	b.WriteString(fmt.Sprintf("\tlog {\n\t\toutput file %s/access-%s.log {\n\t\t\troll_size 50MiB\n\t\t\troll_keep 3\n\t\t}\n\t}\n", cfg.LogDir, host.Domain))

	b.WriteString("}\n\n")
}

func renderReverseProxy(b *strings.Builder, upstreams []model.Upstream, websocket bool) {
	addrs := make([]string, len(upstreams))
	for i, u := range upstreams {
		addrs[i] = u.Address
	}

	b.WriteString(fmt.Sprintf("\treverse_proxy %s {\n", strings.Join(addrs, " ")))

	if len(upstreams) > 1 {
		b.WriteString("\t\tlb_policy round_robin\n")
	}

	// Standard proxy headers
	b.WriteString("\t\theader_up X-Real-IP {remote_host}\n")
	b.WriteString("\t\theader_up X-Forwarded-For {remote_host}\n")
	b.WriteString("\t\theader_up X-Forwarded-Proto {scheme}\n")

	b.WriteString("\t}\n")
}

func renderRoutes(b *strings.Builder, host model.Host) {
	routes := make([]model.Route, len(host.Routes))
	copy(routes, host.Routes)
	sort.Slice(routes, func(i, j int) bool {
		return routes[i].SortOrder < routes[j].SortOrder
	})

	// Build upstream map
	upstreamMap := make(map[uint]model.Upstream)
	for _, u := range host.Upstreams {
		upstreamMap[u.ID] = u
	}

	for _, route := range routes {
		matcherName := fmt.Sprintf("path_%d", route.ID)
		b.WriteString(fmt.Sprintf("\t@%s path %s\n", matcherName, route.Path))

		if route.UpstreamID != nil {
			if u, ok := upstreamMap[*route.UpstreamID]; ok {
				b.WriteString(fmt.Sprintf("\treverse_proxy @%s %s\n", matcherName, u.Address))
			}
		}
	}
}

func renderResponseHeaders(b *strings.Builder, headers []model.CustomHeader) {
	for _, h := range headers {
		switch h.Direction {
		case "response":
			switch h.Operation {
			case "set":
				b.WriteString(fmt.Sprintf("\theader %s \"%s\"\n", h.Name, h.Value))
			case "delete":
				b.WriteString(fmt.Sprintf("\theader -%s\n", h.Name))
			case "add":
				b.WriteString(fmt.Sprintf("\theader +%s \"%s\"\n", h.Name, h.Value))
			}
		case "request":
			// Request headers are set inside reverse_proxy block — handled in renderReverseProxy
			// But as a fallback, add header_up directives
		}
	}
}

func renderAccessRules(b *strings.Builder, rules []model.AccessRule) {
	sortedRules := make([]model.AccessRule, len(rules))
	copy(sortedRules, rules)
	sort.Slice(sortedRules, func(i, j int) bool {
		return sortedRules[i].SortOrder < sortedRules[j].SortOrder
	})

	// Use remote_ip matcher
	var allowIPs, denyIPs []string
	for _, r := range sortedRules {
		switch r.RuleType {
		case "allow":
			allowIPs = append(allowIPs, r.IPRange)
		case "deny":
			denyIPs = append(denyIPs, r.IPRange)
		}
	}

	if len(denyIPs) > 0 {
		b.WriteString(fmt.Sprintf("\t@blocked remote_ip %s\n", strings.Join(denyIPs, " ")))
		b.WriteString("\trespond @blocked 403\n")
	}

	if len(allowIPs) > 0 {
		b.WriteString(fmt.Sprintf("\t@allowed not remote_ip %s\n", strings.Join(allowIPs, " ")))
		b.WriteString("\trespond @allowed 403\n")
	}
}
