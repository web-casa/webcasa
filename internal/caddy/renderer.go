package caddy

import (
	"fmt"
	"sort"
	"strings"
	"time"

	"github.com/caddypanel/caddypanel/internal/config"
	"github.com/caddypanel/caddypanel/internal/model"
)

// RenderCaddyfile generates a complete Caddyfile from the given hosts
func RenderCaddyfile(hosts []model.Host, cfg *config.Config) string {
	var b strings.Builder

	// Header
	b.WriteString("# ============================================\n")
	b.WriteString("# Auto-generated by CaddyPanel\n")
	b.WriteString("# DO NOT EDIT MANUALLY — changes will be overwritten\n")
	b.WriteString(fmt.Sprintf("# Generated at: %s\n", time.Now().Format(time.RFC3339)))
	b.WriteString("# ============================================\n\n")

	// Global options block
	b.WriteString("{\n")
	b.WriteString("\tadmin localhost:2019\n")
	b.WriteString(fmt.Sprintf("\tlog {\n\t\toutput file %s/caddy.log {\n\t\t\troll_size 100MiB\n\t\t\troll_keep 5\n\t\t}\n\t\tlevel INFO\n\t}\n", cfg.LogDir))
	b.WriteString("}\n\n")

	// Host blocks — only enabled hosts
	for _, host := range hosts {
		if host.Enabled != nil && !*host.Enabled {
			continue
		}
		renderHostBlock(&b, host, cfg)
	}

	return b.String()
}

func renderHostBlock(b *strings.Builder, host model.Host, cfg *config.Config) {
	// Domain line
	domain := host.Domain
	if host.TLSEnabled != nil && !*host.TLSEnabled {
		domain = "http://" + domain
	}

	b.WriteString(fmt.Sprintf("%s {\n", domain))

	// TLS — custom certificate
	if host.CustomCertPath != "" && host.CustomKeyPath != "" {
		b.WriteString(fmt.Sprintf("\ttls %s %s\n", host.CustomCertPath, host.CustomKeyPath))
	}

	// Access rules (IP allow/deny) — must come before handlers
	if len(host.AccessRules) > 0 {
		renderAccessRules(b, host.AccessRules)
	}

	// Basic Auth — must come before handlers
	if len(host.BasicAuths) > 0 {
		renderBasicAuth(b, host.BasicAuths)
	}

	// Render based on host type
	switch host.HostType {
	case "redirect":
		renderRedirect(b, host)
	default: // "proxy" or empty (backward compatible)
		renderProxyHost(b, host)
	}

	// Custom directives (raw user-provided Caddy config)
	if host.CustomDirectives != "" {
		for _, line := range strings.Split(strings.TrimSpace(host.CustomDirectives), "\n") {
			b.WriteString(fmt.Sprintf("\t%s\n", line))
		}
	}

	// Per-host access log
	b.WriteString(fmt.Sprintf("\tlog {\n\t\toutput file %s/access-%s.log {\n\t\t\troll_size 50MiB\n\t\t\troll_keep 3\n\t\t}\n\t}\n", cfg.LogDir, host.Domain))

	b.WriteString("}\n\n")
}

func renderRedirect(b *strings.Builder, host model.Host) {
	scheme := "permanent" // 301
	if host.RedirectCode == 302 {
		scheme = "temporary" // 302
	}
	b.WriteString(fmt.Sprintf("\tredir %s%s %s\n", host.RedirectURL, "{uri}", scheme))
}

func renderProxyHost(b *strings.Builder, host model.Host) {
	// Sort upstreams by sort_order
	upstreams := make([]model.Upstream, len(host.Upstreams))
	copy(upstreams, host.Upstreams)
	sort.Slice(upstreams, func(i, j int) bool {
		return upstreams[i].SortOrder < upstreams[j].SortOrder
	})

	// If we have path-based routes, render them separately
	if len(host.Routes) > 0 {
		renderRoutes(b, host)
	} else if len(upstreams) > 0 {
		// Simple reverse proxy (no path routing)
		renderReverseProxy(b, upstreams, host.WebSocket != nil && *host.WebSocket)
	}

	// Custom response headers
	renderResponseHeaders(b, host.CustomHeaders)
}

func renderBasicAuth(b *strings.Builder, auths []model.BasicAuth) {
	b.WriteString("\tbasicauth {\n")
	for _, auth := range auths {
		b.WriteString(fmt.Sprintf("\t\t%s %s\n", auth.Username, auth.PasswordHash))
	}
	b.WriteString("\t}\n")
}

func renderReverseProxy(b *strings.Builder, upstreams []model.Upstream, websocket bool) {
	addrs := make([]string, len(upstreams))
	isPublicURL := false
	for i, u := range upstreams {
		addrs[i] = u.Address
		if strings.HasPrefix(u.Address, "http://") || strings.HasPrefix(u.Address, "https://") {
			isPublicURL = true
		}
	}

	b.WriteString(fmt.Sprintf("\treverse_proxy %s {\n", strings.Join(addrs, " ")))

	if len(upstreams) > 1 {
		b.WriteString("\t\tlb_policy round_robin\n")
	}

	// For public URL upstreams (e.g. https://eol.wiki),
	// set Host header to the upstream's hostname so the target site
	// receives the correct Host header instead of the proxy's domain
	if isPublicURL {
		b.WriteString("\t\theader_up Host {upstream_hostport}\n")
	}

	// X-Real-IP is not set by Caddy by default, so we keep it
	b.WriteString("\t\theader_up X-Real-IP {remote_host}\n")

	b.WriteString("\t}\n")
}

func renderRoutes(b *strings.Builder, host model.Host) {
	routes := make([]model.Route, len(host.Routes))
	copy(routes, host.Routes)
	sort.Slice(routes, func(i, j int) bool {
		return routes[i].SortOrder < routes[j].SortOrder
	})

	// Build upstream map
	upstreamMap := make(map[uint]model.Upstream)
	for _, u := range host.Upstreams {
		upstreamMap[u.ID] = u
	}

	for _, route := range routes {
		matcherName := fmt.Sprintf("path_%d", route.ID)
		b.WriteString(fmt.Sprintf("\t@%s path %s\n", matcherName, route.Path))

		if route.UpstreamID != nil {
			if upstream, ok := upstreamMap[*route.UpstreamID]; ok {
				b.WriteString(fmt.Sprintf("\treverse_proxy @%s %s\n", matcherName, upstream.Address))
			}
		}
	}
}

func renderAccessRules(b *strings.Builder, rules []model.AccessRule) {
	sorted := make([]model.AccessRule, len(rules))
	copy(sorted, rules)
	sort.Slice(sorted, func(i, j int) bool {
		return sorted[i].SortOrder < sorted[j].SortOrder
	})

	for _, rule := range sorted {
		switch rule.RuleType {
		case "allow":
			b.WriteString(fmt.Sprintf("\t@blocked not remote_ip %s\n", rule.IPRange))
			b.WriteString("\tabort @blocked\n")
		case "deny":
			b.WriteString(fmt.Sprintf("\t@denied remote_ip %s\n", rule.IPRange))
			b.WriteString("\tabort @denied\n")
		}
	}
}

func renderResponseHeaders(b *strings.Builder, headers []model.CustomHeader) {
	if len(headers) == 0 {
		return
	}

	sorted := make([]model.CustomHeader, len(headers))
	copy(sorted, headers)
	sort.Slice(sorted, func(i, j int) bool {
		return sorted[i].SortOrder < sorted[j].SortOrder
	})

	b.WriteString("\theader {\n")
	for _, h := range sorted {
		switch h.Operation {
		case "set":
			b.WriteString(fmt.Sprintf("\t\t%s \"%s\"\n", h.Name, h.Value))
		case "add":
			b.WriteString(fmt.Sprintf("\t\t+%s \"%s\"\n", h.Name, h.Value))
		case "delete":
			b.WriteString(fmt.Sprintf("\t\t-%s\n", h.Name))
		}
	}
	b.WriteString("\t}\n")
}
