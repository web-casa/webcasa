package caddy

import (
	"context"
	"fmt"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"sync"
	"time"

	"github.com/caddypanel/caddypanel/internal/config"
)

// Manager handles Caddy process lifecycle and configuration reloading
type Manager struct {
	cfg  *config.Config
	mu   sync.Mutex
	proc *os.Process // tracked only when we start Caddy ourselves
}

// NewManager creates a new Caddy manager
func NewManager(cfg *config.Config) *Manager {
	return &Manager{cfg: cfg}
}

// WriteCaddyfile atomically writes a Caddyfile:
//  1. Write to temp file
//  2. Validate with `caddy validate`
//  3. Backup current file
//  4. Rename temp → final
func (m *Manager) WriteCaddyfile(content string) error {
	m.mu.Lock()
	defer m.mu.Unlock()

	targetPath := m.cfg.CaddyfilePath
	tmpPath := targetPath + ".tmp"
	backupDir := filepath.Join(m.cfg.DataDir, "backups")

	// 1. Write temp file
	if err := os.WriteFile(tmpPath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write temp Caddyfile: %w", err)
	}

	// 2. Validate (skip if caddy binary is not available)
	if _, lookErr := exec.LookPath(m.cfg.CaddyBin); lookErr == nil {
		cmd := exec.Command(m.cfg.CaddyBin, "validate", "--config", tmpPath)
		output, err := cmd.CombinedOutput()
		if err != nil {
			os.Remove(tmpPath)
			return fmt.Errorf("Caddyfile validation failed: %s\n%s", err, string(output))
		}
	} else {
		log.Printf("⚠️  Caddy binary not found (%s), skipping validation", m.cfg.CaddyBin)
	}

	// 3. Backup current file (if exists)
	if _, err := os.Stat(targetPath); err == nil {
		backupName := fmt.Sprintf("Caddyfile.%s.bak", time.Now().Format("20060102-150405"))
		backupPath := filepath.Join(backupDir, backupName)
		data, _ := os.ReadFile(targetPath)
		os.WriteFile(backupPath, data, 0644)

		// Keep only last 10 backups
		m.cleanupBackups(backupDir, 10)
	}

	// 4. Atomic rename
	if err := os.Rename(tmpPath, targetPath); err != nil {
		return fmt.Errorf("failed to rename Caddyfile: %w", err)
	}

	log.Printf("Caddyfile written successfully to %s", targetPath)
	return nil
}

// Reload tells Caddy to reload its configuration
func (m *Manager) Reload() error {
	cmd := exec.Command(m.cfg.CaddyBin, "reload", "--config", m.cfg.CaddyfilePath)
	
	// Force Caddy to use our data dir for certificates, skipping user $HOME permissions
	caddyDataDir := filepath.Join(filepath.Dir(m.cfg.CaddyfilePath), "caddy_data")
	caddyConfigDir := filepath.Join(filepath.Dir(m.cfg.CaddyfilePath), "caddy_config")
	cmd.Env = append(os.Environ(), 
		"XDG_DATA_HOME="+caddyDataDir,
		"XDG_CONFIG_HOME="+caddyConfigDir,
	)

	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("caddy reload failed: %s\n%s", err, string(output))
	}
	log.Println("Caddy reloaded successfully")
	return nil
}

// EnsureCaddyfile creates a minimal valid Caddyfile if one does not exist.
// This allows Caddy to start even before any proxy hosts are configured.
func (m *Manager) EnsureCaddyfile() error {
	if _, err := os.Stat(m.cfg.CaddyfilePath); err == nil {
		return nil // file already exists
	}

	log.Printf("Caddyfile not found at %s, creating default...", m.cfg.CaddyfilePath)

	// Ensure parent directory exists
	os.MkdirAll(filepath.Dir(m.cfg.CaddyfilePath), 0755)

	defaultCaddyfile := fmt.Sprintf(`# ============================================
# Auto-generated by CaddyPanel
# DO NOT EDIT MANUALLY — changes will be overwritten
# ============================================

{
	admin localhost:2019
	log {
		output file %s/caddy.log {
			roll_size 100MiB
			roll_keep 5
		}
		level INFO
	}
}
`, m.cfg.LogDir)

	if err := os.WriteFile(m.cfg.CaddyfilePath, []byte(defaultCaddyfile), 0644); err != nil {
		return fmt.Errorf("failed to create default Caddyfile: %w", err)
	}

	log.Println("Default Caddyfile created successfully")
	return nil
}

// Start starts the Caddy process
func (m *Manager) Start() error {
	m.mu.Lock()
	defer m.mu.Unlock()

	if m.IsRunning() {
		return fmt.Errorf("caddy is already running")
	}

	// Ensure Caddyfile exists before starting (without lock, already held)
	if _, err := os.Stat(m.cfg.CaddyfilePath); os.IsNotExist(err) {
		log.Println("No Caddyfile found, creating default before starting Caddy...")
		os.MkdirAll(filepath.Dir(m.cfg.CaddyfilePath), 0755)
		defaultCfg := fmt.Sprintf("# Auto-generated by CaddyPanel\n{\n\tadmin localhost:2019\n\tlog {\n\t\toutput file %s/caddy.log {\n\t\t\troll_size 100MiB\n\t\t\troll_keep 5\n\t\t}\n\t\tlevel INFO\n\t}\n}\n", m.cfg.LogDir)
		if err := os.WriteFile(m.cfg.CaddyfilePath, []byte(defaultCfg), 0644); err != nil {
			return fmt.Errorf("failed to create default Caddyfile: %w", err)
		}
	}

	ctx, cancel := context.WithTimeout(context.Background(), 15*time.Second)
	defer cancel()

	cmd := exec.CommandContext(ctx, m.cfg.CaddyBin, "start", "--config", m.cfg.CaddyfilePath)
	
	// Force Caddy to use our data dir for certificates
	caddyDataDir := filepath.Join(filepath.Dir(m.cfg.CaddyfilePath), "caddy_data")
	caddyConfigDir := filepath.Join(filepath.Dir(m.cfg.CaddyfilePath), "caddy_config")
	cmd.Env = append(os.Environ(), 
		"XDG_DATA_HOME="+caddyDataDir,
		"XDG_CONFIG_HOME="+caddyConfigDir,
	)

	// IMPORTANT: Do NOT use CombinedOutput() here!
	// `caddy start` forks a background daemon (caddy run) that inherits
	// stdout/stderr pipes. CombinedOutput() waits for pipe EOF, which
	// never happens while the daemon is running → blocks forever.
	// Using Run() with nil Stdout/Stderr avoids creating pipes entirely.
	cmd.Stdout = nil
	cmd.Stderr = nil
	if err := cmd.Run(); err != nil {
		if ctx.Err() == context.DeadlineExceeded {
			return fmt.Errorf("caddy start timed out after 15s")
		}
		return fmt.Errorf("caddy start failed: %v", err)
	}
	log.Println("Caddy started successfully")
	return nil
}

// Stop stops the Caddy process
func (m *Manager) Stop() error {
	m.mu.Lock()
	defer m.mu.Unlock()

	cmd := exec.Command(m.cfg.CaddyBin, "stop")
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("caddy stop failed: %s\n%s", err, string(output))
	}
	log.Println("Caddy stopped successfully")
	return nil
}

// IsRunning checks if a Caddy process is currently running
func (m *Manager) IsRunning() bool {
	// Try to hit the admin API
	cmd := exec.Command("curl", "-s", "-o", "/dev/null", "-w", "%{http_code}", m.cfg.AdminAPI+"/config/")
	output, err := cmd.Output()
	if err != nil {
		return false
	}
	return strings.TrimSpace(string(output)) == "200"
}

// Status returns the current Caddy status
func (m *Manager) Status() map[string]interface{} {
	running := m.IsRunning()
	status := map[string]interface{}{
		"running":        running,
		"caddy_bin":      m.cfg.CaddyBin,
		"caddyfile_path": m.cfg.CaddyfilePath,
	}

	if running {
		// Get Caddy version
		cmd := exec.Command(m.cfg.CaddyBin, "version")
		output, err := cmd.Output()
		if err == nil {
			ver := strings.TrimSpace(string(output))
			if idx := strings.IndexByte(ver, ' '); idx > 0 {
				ver = ver[:idx]
			}
			status["version"] = ver
		}
	}

	return status
}

// GetCaddyfileContent returns the current Caddyfile content
func (m *Manager) GetCaddyfileContent() (string, error) {
	data, err := os.ReadFile(m.cfg.CaddyfilePath)
	if err != nil {
		return "", err
	}
	return string(data), nil
}

// Format formats a Caddyfile string using `caddy fmt`
func (m *Manager) Format(content string) (string, error) {
	cmd := exec.Command(m.cfg.CaddyBin, "fmt", "-")
	cmd.Stdin = strings.NewReader(content)
	output, err := cmd.Output()
	if err != nil {
		return content, nil // return original if formatting fails
	}
	return string(output), nil
}

// Validate validates a Caddyfile string using `caddy validate`
func (m *Manager) Validate(content string) error {
	tmpPath := m.cfg.CaddyfilePath + ".validate.tmp"
	if err := os.WriteFile(tmpPath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write temp file: %w", err)
	}
	defer os.Remove(tmpPath)

	cmd := exec.Command(m.cfg.CaddyBin, "validate", "--config", tmpPath)
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("%s", strings.TrimSpace(string(output)))
	}
	return nil
}

func (m *Manager) cleanupBackups(dir string, keep int) {
	entries, err := os.ReadDir(dir)
	if err != nil {
		return
	}

	var backups []os.DirEntry
	for _, e := range entries {
		if strings.HasPrefix(e.Name(), "Caddyfile.") && strings.HasSuffix(e.Name(), ".bak") {
			backups = append(backups, e)
		}
	}

	if len(backups) <= keep {
		return
	}

	// Sort by name (which includes timestamp), oldest first
	for i := 0; i < len(backups)-keep; i++ {
		os.Remove(filepath.Join(dir, backups[i].Name()))
	}
}
